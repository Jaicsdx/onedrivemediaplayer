<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Online Media Player</title>
  <style>
    :root{
      --bg:#0f1116; --panel:#151823; --muted:#8e95a5; --text:#e6e8ee; --accent:#4f8cff; --accent-2:#22c55e; --danger:#ef4444;
      --radius:18px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"; background:linear-gradient(180deg,#0f1116,#0b0d12); color:var(--text)}
    .app{display:grid; grid-template-columns:360px 1fr; gap:16px; padding:16px; height:100%}
    @media (max-width: 960px){.app{grid-template-columns:1fr; grid-auto-rows:minmax(min-content, max-content)}}
    .card{background:var(--panel); border:1px solid #1f2430; border-radius:var(--radius); box-shadow:0 10px 30px rgba(0,0,0,.35)}
    .sidebar{padding:16px; display:flex; flex-direction:column; gap:16px;}
    h1{font-size:20px; margin:0 0 4px}
    .sub{color:var(--muted); font-size:13px}
    label{font-size:13px; color:var(--muted)}
    input[type="text"], textarea, select{
      width:100%; padding:12px 12px; border-radius:12px; border:1px solid #2a3140; outline:none; background:#0f1420; color:var(--text);
    }
    input[type="file"]{width:100%}
    .row{display:grid; grid-template-columns:1fr; gap:10px}
    .btn{appearance:none; border:none; border-radius:12px; padding:12px 14px; color:white; background:var(--accent); cursor:pointer; font-weight:600}
    .btn.secondary{background:#2a3140}
    .btn.green{background:var(--accent-2)}
    .btn.red{background:var(--danger)}
    .btn.small{padding:8px 10px; font-size:12px; font-weight:700}
    .hint{font-size:12px; color:var(--muted)}
    .stack{display:flex; gap:8px; flex-wrap:wrap}
    .movies{display:grid; grid-template-columns:repeat(auto-fill,minmax(220px,1fr)); gap:16px; padding:16px}
    .movie{background:#0f1420; border:1px solid #232a39; border-radius:16px; overflow:hidden; display:flex; flex-direction:column}
    .movie .thumb{aspect-ratio:16/9; background:linear-gradient(135deg,#1a2030,#0e1320); display:grid; place-items:center; font-weight:700; color:#a7b0c4}
    .movie .body{padding:12px; display:flex; flex-direction:column; gap:10px}
    .movie .title{font-weight:700}
    .tag{font-size:10px; color:#a7b0c4; background:#1b2131; border:1px solid #283044; padding:4px 6px; border-radius:999px}
    .player{display:flex; flex-direction:column; gap:12px; padding:16px; height:100%}
    .player .stage{position:relative; background:black; border-radius:16px; overflow:hidden; border:1px solid #232a39; height:min(70vh, 70dvh)}
    .stage iframe, .stage video{position:absolute; inset:0; width:100%; height:100%; border:0; background:black}
    .controls{display:flex; gap:8px; align-items:center}
    .grow{flex:1}
    .invisible{display:none !important}
    .status{font-size:12px; color:#a7b0c4}
    .searchbar{display:flex; gap:8px}
    .logo{display:flex; align-items:center; gap:8px}
    .logo .dot{width:10px; height:10px; border-radius:50%; background:var(--accent)}
    .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:11px; background:#0b0e15; border:1px solid #25304a; padding:2px 6px; border-radius:6px; color:#c5cbe3}
    details summary{cursor:pointer}
    code.inline{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; background:#0b0e15; border:1px solid #25304a; padding:2px 6px; border-radius:6px; color:#c5cbe3}
  </style>
</head>
<body>
  <div class="app">
    <!-- Sidebar / Admin -->
    <aside class="card sidebar">
      <div class="logo">
        <div class="dot"></div>
        <div>
          <h1>Online Media Player</h1>
          <div class="sub">Add movies (Name + OneDrive link). Links are stored and <strong>movies.json auto-saves</strong> after every change.</div>
        </div>
      </div>

      <div class="row">
        <label>Movie Name</label>
        <input id="movieName" type="text" placeholder="e.g., Inception (2010)" />
      </div>
      <div class="row">
        <label>OneDrive Link or Embed Code</label>
        <textarea id="movieLink" rows="3" placeholder="Paste OneDrive embed link or share URL"></textarea>
        <div class="hint">Tip: In OneDrive, open the video → <span class="kbd">Embed</span> → copy the iframe or URL. This app auto‑converts most OneDrive links to an embed URL to prevent downloading.</div>
      </div>
      <div class="stack">
        <button class="btn" id="addBtn">Add Movie</button>
        <button class="btn secondary" id="updateBtn" disabled>Save Changes</button>
        <button class="btn red" id="cancelEditBtn" disabled>Cancel</button>
      </div>

      <hr style="border-color:#232a39; opacity:.3">

      <div class="searchbar">
        <input id="searchInput" type="text" placeholder="Search movies..." />
        <button class="btn small" id="clearSearchBtn">Clear</button>
      </div>

      <div class="row">
        <label>Data & Saving</label>
        <div class="stack">
          <button class="btn small green" id="exportBtn">Download movies.json</button>
          <label class="btn small secondary" for="importFile" style="cursor:pointer">Import JSON</label>
          <input id="importFile" type="file" accept="application/json" class="invisible" />
          <button class="btn small red" id="clearBtn">Clear All</button>
        </div>
        <div class="stack" style="align-items:center">
          <input id="autoDownloadToggle" type="checkbox" checked>
          <label for="autoDownloadToggle">Always auto‑download <code class="inline">movies.json</code> after edits</label>
        </div>
        <div class="status" id="status">Loading…</div>
      </div>

      <details>
        <summary><strong>Optional:</strong> GitHub Auto‑Sync settings</summary>
        <div class="row">
          <label>Repo (owner/name)</label>
          <input id="ghRepo" type="text" placeholder="yourname/yourrepo" />
        </div>
        <div class="row">
          <label>Branch</label>
          <input id="ghBranch" type="text" value="main" />
        </div>
        <div class="row">
          <label>Path</label>
          <input id="ghPath" type="text" value="movies.json" />
        </div>
        <div class="row">
          <label>Personal Access Token (stored locally)</label>
          <input id="ghToken" type="text" placeholder="ghp_..." />
        </div>
        <div class="stack" style="align-items:center">
          <input id="ghAutoToggle" type="checkbox">
          <label for="ghAutoToggle">Auto‑sync to GitHub on every change</label>
        </div>
        <div class="stack">
          <button class="btn small" id="ghSave">Save Settings</button>
          <button class="btn small secondary" id="ghTest">Test & Sync Now</button>
          <button class="btn small red" id="ghDisable">Disable Sync</button>
        </div>
        <div class="hint">Requires a token with <em>repo</em> scope. Token is only kept in your browser’s local storage.</div>
      </details>

      <div class="hint">
        <strong>Make it permanent on GitHub Pages:</strong>
        <ol style="margin:6px 0 0 16px; padding:0; line-height:1.6">
          <li>Auto‑download happens on each change (file named <span class="kbd">movies.json</span>).</li>
          <li>Upload that file into your GitHub repo (or enable GitHub Auto‑Sync above).</li>
          <li>Deploy with GitHub Pages. Visitors will load the shared <span class="kbd">movies.json</span>.</li>
        </ol>
      </div>
    </aside>

    <!-- Main: Library + Player -->
    <main class="card" style="display:flex; flex-direction:column; min-height:0">
      <div class="player">
        <div class="controls">
          <div class="stack">
            <button class="btn small" id="fullscreenBtn">Fullscreen Player</button>
            <button class="btn small secondary" id="stopBtn">Stop</button>
          </div>
          <div class="grow"></div>
          <div class="status" id="nowPlaying">Nothing playing</div>
        </div>
        <div class="stage" id="stage">
          <!-- We use either <video> for direct files or <iframe> for OneDrive embeds -->
          <video id="video" class="invisible" controls preload="auto" playsinline></video>
          <iframe id="iframe" class="invisible" allow="autoplay; fullscreen; picture-in-picture" referrerpolicy="no-referrer"></iframe>
        </div>
      </div>
      <div class="movies" id="movies"></div>
    </main>
  </div>

<script>
(function(){
  const $ = sel => document.querySelector(sel);
  const storeKey = 'omp_movies_v1';
  const ghKey = 'omp_github_cfg_v1';
  const state = { movies: [], mode: 'local', editingId: null, dirty: false, lastSaveAt: 0 };

  const els = {
    name: $('#movieName'),
    link: $('#movieLink'),
    addBtn: $('#addBtn'),
    updateBtn: $('#updateBtn'),
    cancelEditBtn: $('#cancelEditBtn'),
    exportBtn: $('#exportBtn'),
    importFile: $('#importFile'),
    clearBtn: $('#clearBtn'),
    search: $('#searchInput'),
    clearSearch: $('#clearSearchBtn'),
    status: $('#status'),
    grid: $('#movies'),
    video: $('#video'),
    iframe: $('#iframe'),
    stage: $('#stage'),
    nowPlaying: $('#nowPlaying'),
    fullscreenBtn: $('#fullscreenBtn'),
    stopBtn: $('#stopBtn'),
    autoDownloadToggle: $('#autoDownloadToggle'),
    ghRepo: $('#ghRepo'),
    ghBranch: $('#ghBranch'),
    ghPath: $('#ghPath'),
    ghToken: $('#ghToken'),
    ghAutoToggle: $('#ghAutoToggle'),
    ghSave: $('#ghSave'),
    ghTest: $('#ghTest'),
    ghDisable: $('#ghDisable'),
  };

  // ---------- OneDrive link normalization ----------
  function normalizeOneDriveLink(input){
    if(!input) throw new Error('Empty link');
    let link = input.trim();

    // If user pasted an iframe embed, extract src
    const m = link.match(/<iframe[^>]*src=["']([^"']+)["'][^>]*><\/iframe>/i) || link.match(/src=["']([^"']+)["']/i);
    if(m && m[1]) link = m[1];

    // If already an embed link, keep it
    try{ const u = new URL(link); if(u.hostname.includes('onedrive.live.com')){
      if(u.pathname.includes('/embed')) return link;
      // Convert share link with resid/authkey → embed
      const resid = u.searchParams.get('resid');
      const auth = u.searchParams.get('authkey');
      if(resid){
        const embed = new URL('https://onedrive.live.com/embed');
        embed.searchParams.set('resid', resid);
        if(auth) embed.searchParams.set('authkey', auth);
        embed.searchParams.set('em','2');
        return embed.toString();
      }
    }} catch(e){}

    // 1drv.ms short links usually redirect. We cannot resolve client‑side.
    if(/(^|\.)1drv\.ms\b/.test(link)){
      throw new Error('Short 1drv.ms links cannot be auto‑converted. In OneDrive choose Embed and paste the iframe or the onedrive.live.com embed URL.');
    }

    // Accept other hosts as-is (could be direct mp4/CDN).
    return link;
  }

  // ---------- Storage ----------
  function saveLocal(){
    localStorage.setItem(storeKey, JSON.stringify(state.movies));
  }
  function loadLocal(){
    try{ const raw = localStorage.getItem(storeKey); return raw ? JSON.parse(raw) : []; }
    catch(e){ return []; }
  }

  async function loadRemoteJSON(){
    // Try to fetch movies.json from same folder (works on GitHub Pages)
    try{
      const res = await fetch('movies.json', {cache:'no-store'});
      if(!res.ok) throw new Error('no file');
      const arr = await res.json();
      if(!Array.isArray(arr)) throw new Error('bad format');
      state.mode = 'remote';
      return arr;
    }catch(e){
      state.mode = 'local';
      return null;
    }
  }

  function renderStatus(extra=''){
    const base = state.mode === 'remote'
      ? 'Using shared <kbd>movies.json</kbd> from your site.'
      : 'Using local browser storage. Export/Auto‑download to keep it on GitHub.';
    els.status.innerHTML = base + (extra ? (' — ' + extra) : '');
  }

  // ---------- UI rendering ----------
  function renderMovies(){
    const q = els.search.value.trim().toLowerCase();
    const list = state.movies.filter(m => m.name.toLowerCase().includes(q));
    els.grid.innerHTML = list.map(m => `
      <div class="movie" data-id="${m.id}">
        <div class="thumb">16:9</div>
        <div class="body">
          <div class="title">${escapeHtml(m.name)}</div>
          <div class="stack">
            <span class="tag">${new Date(m.addedAt||Date.now()).toLocaleDateString()}</span>
          </div>
          <div class="stack">
            <button class="btn small" data-action="play">Play</button>
            <button class="btn small secondary" data-action="edit">Edit</button>
            <button class="btn small red" data-action="remove">Delete</button>
          </div>
        </div>
      </div>`).join('') || `<div class="hint" style="padding:12px">No movies yet. Add one on the left.</div>`;
  }

  function playMovie(m){
    if(!m) return;
    const url = m.url;
    const isDirect = /\.(mp4|webm|ogg)(\?.*)?$/i.test(url) || (!/onedrive\.live\.com\/embed/i.test(url) && !/onedrive\.live\.com/i.test(url) && !/1drv\.ms/i.test(url));
    // prefer <video> for direct files, else <iframe> embed
    if(isDirect){
      els.iframe.classList.add('invisible');
      els.iframe.src = 'about:blank';
      els.video.classList.remove('invisible');
      els.video.src = url;
      try {
        els.video.muted = true; // allow autoplay reliably
        els.video.play().catch(()=>{});
      } catch(e){}
    }else{
      els.video.pause?.();
      els.video.src = '';
      els.video.classList.add('invisible');
      els.iframe.classList.remove('invisible');
      els.iframe.src = url;
    }
    els.nowPlaying.textContent = 'Now Playing: ' + m.name;
  }

  function stopPlayback(){
    els.video.pause?.();
    els.video.src = '';
    els.video.classList.add('invisible');
    els.iframe.src = 'about:blank';
    els.iframe.classList.add('invisible');
    els.nowPlaying.textContent = 'Nothing playing';
  }

  function startEdit(m){
    state.editingId = m.id;
    els.name.value = m.name;
    els.link.value = m.url;
    els.addBtn.disabled = true;
    els.updateBtn.disabled = false;
    els.cancelEditBtn.disabled = false;
  }

  function clearEditor(){
    state.editingId = null;
    els.name.value = '';
    els.link.value = '';
    els.addBtn.disabled = false;
    els.updateBtn.disabled = true;
    els.cancelEditBtn.disabled = true;
  }

  function escapeHtml(s){
    return s.replace(/[&<>"]+/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));
  }

  // ---------- Auto-save: download + optional GitHub sync ----------
  let persistTimer = null;
  function markDirty(){
    state.dirty = true;
    // debounce persist to avoid spamming on quick edits
    clearTimeout(persistTimer);
    persistTimer = setTimeout(autoPersist, 700);
  }

  function autoPersist(){
    if(!state.dirty) return;
    state.dirty = false;
    saveLocal();
    if(els.autoDownloadToggle.checked){
      downloadMoviesJson(); // always save a fresh movies.json
    }
    if(loadGhCfg().auto){
      githubSync().catch(err => renderStatus('GitHub sync failed (see console)'));
    }
    state.lastSaveAt = Date.now();
    renderStatus('Saved ' + new Date(state.lastSaveAt).toLocaleTimeString());
  }

  function downloadMoviesJson(){
    const blob = new Blob([JSON.stringify(state.movies, null, 2)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'movies.json'; a.click();
    setTimeout(()=>URL.revokeObjectURL(url), 1000);
  }

  // ---------- GitHub Sync (optional) ----------
  function loadGhCfg(){
    try{
      const raw = localStorage.getItem(ghKey);
      return raw ? JSON.parse(raw) : { repo:'', branch:'main', path:'movies.json', token:'', auto:false };
    }catch(e){ return { repo:'', branch:'main', path:'movies.json', token:'', auto:false }; }
  }
  function saveGhCfg(cfg){
    localStorage.setItem(ghKey, JSON.stringify(cfg));
  }
  function applyGhCfgToUI(){
    const cfg = loadGhCfg();
    els.ghRepo.value = cfg.repo || '';
    els.ghBranch.value = cfg.branch || 'main';
    els.ghPath.value = cfg.path || 'movies.json';
    els.ghToken.value = cfg.token || '';
    els.ghAutoToggle.checked = !!cfg.auto;
  }

  async function githubGetFile(cfg){
    const url = `https://api.github.com/repos/${encodeURIComponent(cfg.repo)}/contents/${encodeURIComponent(cfg.path)}?ref=${encodeURIComponent(cfg.branch)}`;
    const res = await fetch(url, { headers: ghHeaders(cfg) });
    if(res.status === 404) return { sha: null };
    if(!res.ok) throw new Error('GET ' + res.status + ': ' + await res.text());
    const json = await res.json();
    return { sha: json.sha };
  }
  function ghHeaders(cfg){
    const h = { 'Accept': 'application/vnd.github+json' };
    if(cfg.token) h['Authorization'] = `token ${cfg.token}`;
    return h;
  }
  function toBase64(str){
    // base64 for unicode
    return btoa(unescape(encodeURIComponent(str)));
  }
  async function githubPutFile(cfg, content, sha){
    const url = `https://api.github.com/repos/${encodeURIComponent(cfg.repo)}/contents/${encodeURIComponent(cfg.path)}`;
    const body = {
      message: 'Update movies.json via Online Media Player',
      content: toBase64(content),
      branch: cfg.branch || 'main',
    };
    if(sha) body.sha = sha;
    const res = await fetch(url, { method:'PUT', headers: ghHeaders(cfg), body: JSON.stringify(body) });
    if(!res.ok) throw new Error('PUT ' + res.status + ': ' + await res.text());
    return res.json();
  }
  async function githubSync(){
    const cfg = loadGhCfg();
    if(!cfg.repo || !cfg.path || !cfg.branch || !cfg.token){
      throw new Error('Missing GitHub settings');
    }
    const current = await githubGetFile(cfg);
    const content = JSON.stringify(state.movies, null, 2);
    await githubPutFile(cfg, content, current.sha);
    renderStatus('GitHub sync OK');
  }

  // ---------- Event handlers ----------
  els.addBtn.addEventListener('click', () => {
    const name = els.name.value.trim();
    const raw = els.link.value.trim();
    if(!name || !raw){ alert('Please enter a movie name and a OneDrive link.'); return; }
    let link;
    try{ link = normalizeOneDriveLink(raw); }
    catch(e){ alert(e.message); return; }

    const movie = { id: crypto.randomUUID(), name, url: link, addedAt: Date.now() };
    state.movies.unshift(movie);
    renderMovies();
    clearEditor();
    markDirty();
  });

  els.updateBtn.addEventListener('click', () => {
    if(!state.editingId) return;
    const name = els.name.value.trim();
    const raw = els.link.value.trim();
    if(!name || !raw){ alert('Please enter a movie name and a OneDrive link.'); return; }
    let link;
    try{ link = normalizeOneDriveLink(raw); }
    catch(e){ alert(e.message); return; }

    const i = state.movies.findIndex(m => m.id === state.editingId);
    if(i>=0){ state.movies[i] = { ...state.movies[i], name, url: link }; }
    renderMovies();
    clearEditor();
    markDirty();
  });

  els.cancelEditBtn.addEventListener('click', clearEditor);

  els.grid.addEventListener('click', (e) => {
    const btn = e.target.closest('button');
    if(!btn) return;
    const card = e.target.closest('.movie');
    const id = card?.dataset.id;
    const m = state.movies.find(x => x.id === id);
    if(!m) return;

    const action = btn.dataset.action;
    if(action === 'play') playMovie(m);
    else if(action === 'edit') startEdit(m);
    else if(action === 'remove'){
      if(confirm('Delete this movie?')){
        const i = state.movies.findIndex(x => x.id === id);
        if(i>=0) state.movies.splice(i,1);
        renderMovies();
        if(els.nowPlaying.textContent.includes(m.name)) stopPlayback();
        markDirty();
      }
    }
  });

  els.exportBtn.addEventListener('click', () => {
    downloadMoviesJson();
  });

  els.importFile.addEventListener('change', async () => {
    const file = els.importFile.files[0]; if(!file) return;
    try{
      const text = await file.text();
      const arr = JSON.parse(text);
      if(!Array.isArray(arr)) throw new Error('Invalid JSON: expected an array');
      // Basic sanitize
      state.movies = arr.map(x => ({ id: x.id || crypto.randomUUID(), name: String(x.name||'Untitled'), url: String(x.url||''), addedAt: x.addedAt||Date.now() }));
      renderMovies();
      markDirty();
      alert('Imported successfully!');
    }catch(err){ alert('Import failed: ' + err.message); }
    finally{ els.importFile.value = ''; }
  });

  els.clearBtn.addEventListener('click', () => {
    if(confirm('Clear all movies from this browser?')){
      state.movies = [];
      renderMovies();
      stopPlayback();
      markDirty();
    }
  });

  els.search.addEventListener('input', renderMovies);
  els.clearSearch.addEventListener('click', () => { els.search.value=''; renderMovies(); });

  els.fullscreenBtn.addEventListener('click', () => {
    const el = els.stage;
    if(document.fullscreenElement){ document.exitFullscreen(); }
    else{ el.requestFullscreen?.(); }
  });

  els.stopBtn.addEventListener('click', stopPlayback);

  // GitHub settings handlers
  els.ghSave.addEventListener('click', () => {
    const cfg = {
      repo: els.ghRepo.value.trim(),
      branch: els.ghBranch.value.trim() || 'main',
      path: els.ghPath.value.trim() || 'movies.json',
      token: els.ghToken.value.trim(),
      auto: !!els.ghAutoToggle.checked,
    };
    saveGhCfg(cfg);
    renderStatus('GitHub settings saved');
  });
  els.ghTest.addEventListener('click', async () => {
    try{
      await githubSync();
      alert('GitHub sync successful!');
    }catch(e){
      console.error(e);
      alert('GitHub sync failed: ' + e.message);
    }
  });
  els.ghDisable.addEventListener('click', () => {
    saveGhCfg({ repo:'', branch:'main', path:'movies.json', token:'', auto:false });
    applyGhCfgToUI();
    renderStatus('GitHub sync disabled');
  });

  // Warn user and force-save on unload if dirty
  window.addEventListener('beforeunload', (e) => {
    if(state.dirty){
      // do a last-second auto-download
      downloadMoviesJson();
      e.preventDefault();
      e.returnValue = '';
    }
  });

  // ---------- Init ----------
  (async function init(){
    // Load GitHub cfg to UI
    applyGhCfgToUI();

    // Prefer remote movies.json if present, else local
    const remote = await loadRemoteJSON();
    if(remote){ state.movies = remote; }
    else{ state.movies = loadLocal(); }

    renderStatus();
    renderMovies();
  })();
})();
</script>
</body>
</html>
